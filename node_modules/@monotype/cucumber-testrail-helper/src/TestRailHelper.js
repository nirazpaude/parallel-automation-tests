const fs = require('fs');
const rp = require('request-promise-native');
const path = require('path');

const testrailConfig = require('./config/testrail.config.json');

const TestNameRegex = /^C?(\d+):.*$/;
const TableLineRegex = /^\s*?\|\s*?(\d+)\s*?\|.*$/;
const OutcomeMap = {
  ambiguous: 'RETEST',
  failed: 'FAILED',
  passed: 'PASSED',
  pending: 'BLOCKED',
  skipped: 'RETEST',
  undefined: 'NOT APPLICABLE',
};

class TestRailHelper {
  constructor() {
    this.TestRailConfig = testrailConfig;
    this.ScenarioLines = {};
    this.TestRunProperties = {};
    const consumerDirectory = path.dirname(module.parent.filename);

    // need to test for override of the testrail config file
    const testRunConfigFilePath = `${consumerDirectory}/testrail.config.json`;
    try {
      fs.accessSync(testRunConfigFilePath); // default option is F_OK / file existence

      try {
        const tempConfig = JSON.parse(fs.readFileSync(testRunConfigFilePath));
        this.TestRailConfig = Object.assign({}, this.TestRailConfig, tempConfig);
      } catch (err) {
        throw new Error(`ERROR: Reading file at path ${testRunConfigFilePath}`);
      }
    } catch (err) {
      // overide config file does not exist... continue
    }

    // test to see if saving results is true in which case look for a config file
    if (this.TestRailConfig.SaveResultsToTestRail === true) {
      const testRunPropertiesFilePath = `${consumerDirectory}/${this.TestRailConfig.TestRunPropertiesFile}`;

      try {
        fs.accessSync(testRunPropertiesFilePath); // default option is F_OK / file existence
        this.TestRunPropertiesStream = fs.createReadStream(testRunPropertiesFilePath);
      } catch (err) {
        throw new Error(`ERROR: Reading file at path ${testRunPropertiesFilePath}`);
      }
    }
  }

  /**
   * Initializes the test run, cleaning old results and creating a run in
   * TestRail if configured to post results to TestRail
   */
  async initializeTestRun() {
    if (this.TestRailConfig.SaveResultsToTestRail) {
      try {
        // check if it exists first, if not we can move on no problem
        fs.accessSync(this.TestRailConfig.ResultsFile); // default option is F_OK / file existence
        try {
          // check if we can write (to delete) the file
          fs.accessSync(this.TestRailConfig.ResultsFile, fs.constants.W_OK);
          fs.unlinkSync(this.TestRailConfig.ResultsFile);
        } catch (err) {
          throw new Error(`ERROR: File ${this.TestRailConfig.ResultsFile} could not be deleted.`);
        }
      } catch (err) {
        // This isn't a problem - no file is present to be cleaned up - so we can move on
      }

      // Create test run in TestRail where results can be posted
      const url = `${this.TestRailConfig.QEHelperApiBaseUrl}TestRunProperties/InitializeTestRailRunUsingPropertiesFile`;
      const formData = {
        TestRunPropertiesFile: this.TestRunPropertiesStream,
        TestRunPropertiesFileFormat: 'json',
      };
      const responseBody = await rp.post({ url, formData });
      this.TestRunProperties = JSON.parse(responseBody);
    }
  }

  /**
   * Loads lines of .feature file into instance variable for parsing later
   *
   * @param {string} featureFile filepath to .feature file
   */
  loadLines(featureFile) {
    const fileData = fs.readFileSync(featureFile, 'utf8');
    this.ScenarioLines[featureFile] = fileData.split('\n');
  }

  /**
   * Processes a single test result
   *
   * @param {Object} result
   * @returns {TestRailResult}
   */
  processScenarioResult(scenario) {
    const testRailResult = {
      TestOutcome: OutcomeMap[scenario.result.status],
      TestExecutionTime: scenario.result.duration,
    };
    const commentLines = [];
    const featureFile = scenario.sourceLocation.uri;

    let matches;

    if (scenario.pickle.locations.length > 1) {
      // table-driven scenario
      commentLines.push(`${featureFile}:(${scenario.pickle.locations[1].line},${scenario.pickle.locations[0].line})`);
      if (testRailResult.TestOutcome === 'FAILED') {
        commentLines.push(scenario.result.exception.stack);
      }
      if (!Object.keys(this.ScenarioLines).includes(featureFile)) {
        this.loadLines(featureFile);
      }
      const tableLineNum = scenario.sourceLocation.line - 1;
      const tableLine = this.ScenarioLines[featureFile][tableLineNum];
      if (!TableLineRegex.test(tableLine)) {
        throw new Error(`Failed to parse test case ID from line ${tableLineNum}: "${tableLine}"`);
      }
      matches = TableLineRegex.exec(tableLine);
    } else {
      // "normal" scenario
      commentLines.push(`${featureFile}:${scenario.sourceLocation.line}`);
      if (testRailResult.TestOutcome === 'FAILED') {
        commentLines.push(scenario.result.exception.stack);
      }
      if (!TestNameRegex.test(scenario.pickle.name)) {
        throw new Error(`Scenario name is not formatted correctly with test case ID: "${scenario.pickle.name}"`);
      }
      matches = TestNameRegex.exec(scenario.pickle.name);
    }

    testRailResult.TestRailCaseId = parseInt(matches[1], 10);
    testRailResult.TestComments = commentLines.join('\n');

    return testRailResult;
  }

  /**
   * Processes a list of test results (only if posting to TestRail)
   *
   * @param {Object[]} results list of results from Cucumber.js' After hook
   */
  async processScenarioResults(results) {
    if (this.TestRailConfig.SaveResultsToTestRail) {
      const formattedResults = results.map(this.processScenarioResult, this);
      this.writeResultsToFile(formattedResults);
      await this.postToTestRail();
    }
  }

  /**
   * Writes the formatted results to filepath specified in testrail settings
   */
  writeResultsToFile(results) {
    if (this.TestRailConfig.ResultsFile.length === 0) {
      throw new Error('Error: No ResultsFile set in the testrail config');
    }
    const filepath = this.TestRailConfig.ResultsFile;
    fs.writeFileSync(filepath, JSON.stringify(results));
  }

  /**
   * Posts results to TestRail (if config flag is set)
   */
  async postToTestRail() {
    if (this.TestRailConfig.SaveResultsToTestRail) {
      const url = `${this.TestRailConfig.QEHelperApiBaseUrl}TestRailResults/Monotype`;
      const formData = {};
      // skip null keys, stringify boolean keys, and fix key name mismatch
      Object.keys(this.TestRunProperties[0]).forEach((key) => {
        if (this.TestRunProperties[0][key] === null) {
          return;
        }
        if (key === 'MT_RUN_TESTRAILTESTRUNID') {
          formData.MT_RUN_TESTRAILRUNID = this.TestRunProperties[0][key];
        } else if (typeof this.TestRunProperties[0][key] === 'boolean') {
          formData[key] = this.TestRunProperties[0][key].toString();
        } else {
          formData[key] = this.TestRunProperties[0][key];
        }
      });
      formData.ResultsFile = fs.createReadStream(this.TestRailConfig.ResultsFile);
      await rp.post({ url, formData });
    }
  }
}

/**
 * @typedef {Object} TestRailResult
 * @property {number} TestRailCaseId Case ID in TestRail
 * @property {string} TestOutcome PASSED, FAILED, BLOCKED, RETEST, NOT APPLICABLE
 * @property {string} TestComments "catch-all" for any relevant info about test execution
 * @property {string} TestExecutionTime Duration in milliseconds
 */

module.exports = TestRailHelper;
